# Dynamic Programming

## 1520 - 내리막길

계속해서 시간초과가 났는데 그 이유가 memoization을 -1로 안해서 그러함. memoization을 0으로 초기화했을때의 문제는 배열의 특정위치에서 이게 0인 이유가 처음 방문해서 0인건지 경로가 없어서 0인건지 구별이 안되서임. 따라서, 이 부분문제를 반복적으로 풀게되기 때문에 시간초과가 난다.

```C
int dx[] = { 0, 0, 1, -1 };
int dy[] = { 1, -1, 0, 0 };

int go(int x, int y){
	if (x == 0 && y == 0) return 1;
	if (d[x][y] > 0) return d[x][y];
    for (int k = 0; k<4; k++){
		int nx = x + dx[k];
		int ny = y + dy[k];
		if (nx >= 0 && nx < n && ny >= 0 && ny < m){
			if (a[nx][ny] > a[x][y]){
				d[x][y] += go(nx, ny);
			}
		}
	}
	return d[x][y];
}

```

## 2193 - 이친수

입력 N의 범위는 1 ~ 90인데 피보나치 점화식 90번은 그 횟수가 int의 범위를 넘어가므로 long long타입으로 해야한다.

## 5557 - 1학년

점화식을 세우는데 애먹었는데 memoization을 2차원 배열로 만들어 각 위치에서의 값을 기록하면서 진행하면 된다.

## 1509 - 팰린드롬 분할

1차적으로 모든 경우에 대하여 팰린드롬인지 확인 한 후에, 문장의 끝에서부터 처음까지 모든 경우의 수를 체크하며 최솟값을 구하면 된다.

## 11055 - 가장 긴 바이토닉 부분 수열

가장 긴 부분 수열을 기준점을 세워 위 아래로 2번 수행하면 된다. 또한 메모이제이션을 1로 초기화 해주어야 한다.

## 2631 - 줄 세우기

> LIS 문제라는 것을 파악해야 한다.

무작위로 번호가 섞여있을 때, LIS(Longest Increase Sequence)를 찾아 전체 길이 N에서 빼주면 된다.

## 12699 - ABC

가장 중요한 것은, 특정 위치 x에서 'A', 'B', 'C'가 왔을 때 부분 수열의 갯수가 변하는 규칙이 있다는 것이다.

* x번째 문자가 'A'일 때, 부분수열의 갯수는 변하지 않는다.
* x번째 문자가 'B'일 때, 부분수열의 갯수는 <b><i>부분수열 갯수 + 'A'의 갯수</i></b> 이다.
* x번째 문자가 'C'일 때, 부분수열의 갯수는 <b><i>부분수열 갯수 + 'A'의 갯수 + 'B'의 갯수</i></b> 이다.

이 점을 고려하여 풀면 된다.

또한, memoization을 활용해야한다. 3의 30제곱은 엄청 큰 수이기 때문에 완전탐색으로 풀 수 없다.

```C
bool memo[31][31][31][436];

if(memo[x][a][b][p]) return false;
memo[x][a][b][p] = true;
```

배열은 특정 위치 x에서 a의 갯수, b의 갯수, 부분수열의 갯수를 의미한다. 차후에 반복적으로, 방문의사를 확인한다면 이는 false를 반환했을 것이다. 따라서, 재귀함수 호출을 하기 이전에 false를 반환하며 끝내버리면 된다.