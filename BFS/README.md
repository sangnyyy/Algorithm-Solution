# DFS, BFS

## 12851 - 숨바꼭질2

n = 1, k = 3이라고 가정했을 때, 최단시간의 경우의 수는 1X2+1, 1+1+1로 2가지가 된다. 나는 기존에 큐에 push를 하면서 방문여부를 체크했는데 이렇게 구현하게 되면 1+1에서 방문으로 체크된 경우가 1X2의 조건에서 큐에 들어가지 않기 때문에 경우의 수를 잡아 낼 수가 없게 된다. 따라서 큐에서 front를 pop하면서 방문여부를 true로 해주게 되면 모든 경우의 수를 잡아 낼 수가 있게 된다.

## 9019 - DSLR

개행을 안해줘서 틀리는 아주 사소한 부분의 문제였지만 많은 것을 배울 수 있었던 문제이다.

* 숫자를 왼쪽으로 한칸씩 이동(4자리수)

```C
int left = (n%1000)*10 + n/1000;
```

* 숫자를 오른쪽으로 한칸씩 이동(4자리수)

```C
int right = (n/10) + (n%10)*1000;
```

## 2206 - 벽 부수고 이동하기

방문 배열을 3차원 배열(ex. bool[1001][1001][2])로 만들어 해당 지점을 벽을 부수고 방문했는지 혹은 그냥 방문했는지를 파악하는게 관건이었다. 나는 그냥 벽을 부수었는지 안부수었는지를 큐의 입장에서만 알고 있으면 된다 생각했지만, 배열의 입장에서 벽을 안부수고 특정지점에 도달하여 방문했다고 체크를 해버리면 벽을 부수고 오던 특정지점에서 더이상 진행을 할 수 없게 되어버리는 경우가 발생하기 때문이다.